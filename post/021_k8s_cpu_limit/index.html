<!doctype html><!-- This site was created with Wowchemy. https://www.wowchemy.com --><!-- Last Published: March 6, 2025 --><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Wowchemy 5.7.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Lora&family=Work+Sans&family=Montserrat:wght@400;700&family=Roboto+Mono:wght@400;700&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Lora&family=Work+Sans&family=Montserrat:wght@400;700&family=Roboto+Mono:wght@400;700&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><script src=/js/mathjax-config.js></script><link rel=stylesheet href=/css/vendor-bundle.min.047268c6dd09ad74ba54a0ba71837064.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/academicons@1.9.2/css/academicons.min.css integrity="sha512-KlJCpRsLf+KKu2VQa5vmRuClRFjxc5lXO03ixZt82HZUk41+1I0bD8KBSA0fY290ayMfWYI9udIqeOWSu1/uZg==" crossorigin=anonymous media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script><link rel=stylesheet href=/css/wowchemy.176e9a6c2874fb96332dfb10e8718f70.css><link rel=stylesheet href=/css/libs/chroma/github-dark.min.css title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=/css/libs/chroma/github-dark.min.css title=hl-dark media=print onload='this.media="all"' disabled><meta name=author content="Wit Sirawit"><meta name=description content="As a software engineer at a big tech company, I usually rely on an infrastructure team to provide deployment tools for us. While convenient, this, I realized, is a missed learning opportunity."><link rel=alternate hreflang=en-us href=https://witsblog.github.io/post/021_k8s_cpu_limit/><link rel=canonical href=https://witsblog.github.io/post/021_k8s_cpu_limit/><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu66cf44b0d2eab4dae9de00f68d847da7_1567_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu66cf44b0d2eab4dae9de00f68d847da7_1567_180x180_fill_lanczos_center_3.png><meta name=theme-color content="#2962ff"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:image" content="https://witsblog.github.io/post/021_k8s_cpu_limit/featured.png"><meta property="og:site_name" content="Wit's Blog"><meta property="og:url" content="https://witsblog.github.io/post/021_k8s_cpu_limit/"><meta property="og:title" content="Ever Wonder How Kubernetes CPU Limit Can Be a Fraction? | Wit's Blog"><meta property="og:description" content="As a software engineer at a big tech company, I usually rely on an infrastructure team to provide deployment tools for us. While convenient, this, I realized, is a missed learning opportunity."><meta property="og:image" content="https://witsblog.github.io/post/021_k8s_cpu_limit/featured.png"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2023-02-04T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-04T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://witsblog.github.io/post/021_k8s_cpu_limit/"},"headline":"Ever Wonder How Kubernetes CPU Limit Can Be a Fraction?","image":["https://witsblog.github.io/post/021_k8s_cpu_limit/featured.png"],"datePublished":"2023-02-04T00:00:00Z","dateModified":"2023-02-04T00:00:00Z","author":{"@type":"Person","name":"Wit Sirawit"},"publisher":{"@type":"Organization","name":"Wit's Blog","logo":{"@type":"ImageObject","url":"https://witsblog.github.io/media/icon_hu66cf44b0d2eab4dae9de00f68d847da7_1567_192x192_fill_lanczos_center_3.png"}},"description":"As a software engineer at a big tech company, I usually rely on an infrastructure team to provide deployment tools for us. While convenient, this, I realized, is a missed learning opportunity."}</script><title>Ever Wonder How Kubernetes CPU Limit Can Be a Fraction? | Wit's Blog</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=69f2b0811c2a0e0f9d5fced7105c4bfc><script src=/js/wowchemy-init.min.fe8634e7d00f14d07fb33caf14cc8e55.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=Close><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control aria-label=Search...></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><div class="page-header header--fixed"><header><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Wit's Blog</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Wit's Blog</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/#posts><span>Posts</span></a></li><li class=nav-item><a class=nav-link href=/#about><span>About</span></a></li><li class=nav-item><a class=nav-link href=/#projects><span>Projects</span></a></li><li class=nav-item><a class=nav-link href=/#gallery><span>Gallery</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=Search><i class="fas fa-search" aria-hidden=true></i></a></li></ul></div></nav></header></div><div class=page-body><article class=article><div class="article-container pt-3"><h1>Ever Wonder How Kubernetes CPU Limit Can Be a Fraction?</h1><div class=article-metadata><span class=article-date>Feb 4, 2023
</span><span class=middot-divider></span>
<span class=article-reading-time>6 min read</span></div></div><div class="article-header container featured-image-wrapper mt-4 mb-4" style=max-width:1039px;max-height:486px><div style=position:relative><img src=/post/021_k8s_cpu_limit/featured_hu5a877c95ec7e280f7f4de122f7d5ee37_54674_1200x2500_fit_q75_h2_lanczos_3.webp width=1039 height=486 alt class=featured-image></div></div><div class="container-fluid docs"><div class="row flex-xl-nowrap"><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>Contents</a></li></ul><nav id=TableOfContents><ul><li><a href=#requests-and-limit>Requests and Limit</a></li><li><a href=#cfs-bandwidth-control>CFS Bandwidth Control</a><ul><li><a href=#the-mechanism>The Mechanism</a></li><li><a href=#more-is-revealed-in-the-kernel-code>More is Revealed in the Kernel Code</a></li><li><a href=#a-side-note-about-spinlock>A Side Note About Spinlock</a></li></ul></li><li><a href=#should-we-set-the-cpu-limit>Should We Set the CPU Limit?</a></li><li><a href=#references>References</a></li></ul></nav></div><div class=article-container><div class=article-style><p>As a software engineer at a big tech company, I usually rely on an infrastructure team to provide deployment tools for us. While convenient, this, I realized, is a missed learning opportunity.</p><p>One of the things that I have been curious about all along is</p><ul><li>How does Kubernetes limits CPU and memory resource?</li><li>How can CPU allocation even be a fraction and less than 1?</li></ul><p>Curiosity got the better of me, and I decided to explore how Kubernetes handles this task.</p><br><h2 id=requests-and-limit>Requests and Limit</h2><p>When we deploy our service, we can specify the resource <code>request</code> and <code>limit</code>. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;256Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;250m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;768Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;750m&#34;</span><span class=w>
</span></span></span></code></pre></div><p>Basically,</p><ul><li><p>CPU</p><ul><li><code>request</code><ul><li>Used during the Pod scheduling. When Kubernetes scheduler selects a node for the Pod to run on, it ensures that the <code>request</code> does not exceed the capacity of the node.</li><li>The workloads are allocated CPU time proportionally to the <code>request</code>.</li></ul></li><li><code>limit</code><ul><li>This sets the hard limit during each <em><strong>scheduling interval</strong></em>. If the execution time exceeds, the OS kernel will throttle.<blockquote><p>The CPU limit defines a hard ceiling on how much CPU time that the container can use. During each scheduling interval (time slice), the Linux kernel checks to see if this limit is exceeded; if so, the kernel waits before allowing that cgroup to resume execution.</p></blockquote></li></ul></li></ul></li><li><p>Memory</p><ul><li><code>request</code><ul><li>Similar to CPU <code>request</code>, this is used during the Pod scheduling.</li></ul></li><li><code>limit</code><ul><li>The effect of this is such that, if the container tries to allocate more memory than this limit, it will get <em>OOM (out of memory)</em> error.</li></ul></li></ul></li></ul><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=/post/020_k8s_cpu_limit/featured.png alt loading=lazy data-zoomable></div></div></figure></p><br><h2 id=cfs-bandwidth-control>CFS Bandwidth Control</h2><h3 id=the-mechanism>The Mechanism</h3><blockquote><p>How does Kubernetes limit the CPU?</p></blockquote><p>Kubernetes limits the resource by means of the <a href=https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/cgroups.html target=_blank rel=noopener>cgroup</a> concept in the Linux kernel.</p><p>For CPU <code>limit</code>, this is done by the <a href=https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html target=_blank rel=noopener>CFS Bandwidth Control</a> in the Linux kernel. The bandwidth allowed for a group is specified using a <strong>quota</strong> and <strong>period</strong>.</p><ul><li><p>For cgroup v1, these settings are located in <code>/sys/fs/cgroup/cpu,cpuacct/</code>, where the quota and period are in <code>cpu.cfs_quota_us</code> and <code>cpu.cfs_period_us</code> respectively.</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=/images/post/021/02.png alt loading=lazy data-zoomable></div></div></figure></p></li><li><p>For cgroup v2, these settings are in <code>/sys/fs/cgroup/cpu.max</code>, in the following format</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt;quota&gt; &lt;preiod&gt;
</span></span></code></pre></div><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=/images/post/021/03.png alt loading=lazy data-zoomable></div></div></figure></p></li></ul><p>Essentially</p><ul><li>Within each given <strong>period</strong> (
${\mu}s$), a task group is allocated up to <strong>quota</strong> (
${\mu} s$) of CPU time.</li><li>If the <strong>quota</strong> is fully utilized before the <strong>period</strong> ends, any additional requests for CPU time will result in those threads in the group being throttled. They won&rsquo;t be able to run again until the quota is replenished in the next <strong>period</strong>.</li><li>The allocated <strong>quota</strong> is divided and assigned to per-CPU run queues in <strong>slice</strong> as threads within the cgroup become runnable. This is a system wide setting in <code>/proc/sys/kernel/sched_cfs_bandwidth_slice_us</code> with default value = 5 ms.</li><li>Unused quota is tracked globally and is refreshed at each period boundary.</li></ul><blockquote><p>So how can CPU <code>limit</code> be a fraction? How can it be less than 1?</p></blockquote><p>Let&rsquo;s visualize. Assume a task takes 125 ms to process. This is what would happen if we <strong>don&rsquo;t</strong> set the CPU <code>limit</code>:</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=/images/post/021/04.png alt loading=lazy data-zoomable></div></div></figure></p><p>If we set CPU <code>limit</code> to <code>0.25</code> CPU or <code>250m</code> CPU, Kubernetes would set <strong>quota</strong>
$= 0.25 \times 100 = 25$ ms. So this means that within a (default) 100 ms <strong>period</strong>, the task can use up 25 ms, and it will finish at 425 ms (instead of 125 ms, what a surprise!):</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=/images/post/021/05.png alt loading=lazy data-zoomable></div></div></figure></p><p>If we look at the <code>cpu.stat</code>, we would probably see:</p><table><thead><tr><th>Statistics</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td><code>nr_periods</code></td><td>5</td><td>Number of intervals that have elapsed.</td></tr><tr><td><code>nr_throttled</code></td><td>4</td><td>Number of times the group has been throttled.</td></tr><tr><td><code>throttled_usec</code></td><td>300000</td><td>The total time duration for which the group have been throttled.</td></tr></tbody></table><p>From the following calculation, the throttled rate would be ~80% !</p>$$throttled \space \% = \frac{nr\_throttled}{nr\_periods}$$<h3 id=more-is-revealed-in-the-kernel-code>More is Revealed in the Kernel Code</h3><blockquote><p>What if the CPU <code>limit</code> is greater than 1? This means the <strong>quota</strong> would be greater than the <strong>period</strong>. How can it still be throttled?</p></blockquote><p>In a real system, there are multiple CPU cores. The Linux kernel tracks the quota from the <strong>global pool</strong> rather than on a per-CPU basis. So even though the time used in each period per CPU core cannot exceed the <strong>period</strong> itself, the total sum of <strong>quota</strong> across multiple cores can be greater than the period. This can result in throttling:</p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=/images/post/021/06.webp alt loading=lazy data-zoomable></div></div></figure><p>If we look at the kernel <a href=https://github.com/torvalds/linux target=_blank rel=noopener>code</a>, we would actaully see it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>__assign_cfs_rq_runtime</span><span class=p>(</span><span class=k>struct</span> <span class=n>cfs_bandwidth</span> <span class=o>*</span><span class=n>cfs_b</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=k>struct</span> <span class=n>cfs_rq</span> <span class=o>*</span><span class=n>cfs_rq</span><span class=p>,</span> <span class=n>u64</span> <span class=n>target_runtime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>u64</span> <span class=n>min_amount</span><span class=p>,</span> <span class=n>amount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>lockdep_assert_held</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>min_amount</span> <span class=o>=</span> <span class=n>target_runtime</span> <span class=o>-</span> <span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>runtime_remaining</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>quota</span> <span class=o>==</span> <span class=n>RUNTIME_INF</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>amount</span> <span class=o>=</span> <span class=n>min_amount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>start_cfs_bandwidth</span><span class=p>(</span><span class=n>cfs_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>runtime</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>amount</span> <span class=o>=</span> <span class=nf>min</span><span class=p>(</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>runtime</span><span class=p>,</span> <span class=n>min_amount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>runtime</span> <span class=o>-=</span> <span class=n>amount</span><span class=p>;</span> <span class=c1>// &lt;---------- Take from the global pool
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>idle</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>runtime_remaining</span> <span class=o>+=</span> <span class=n>amount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>runtime_remaining</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>assign_cfs_rq_runtime</span><span class=p>(</span><span class=k>struct</span> <span class=n>cfs_rq</span> <span class=o>*</span><span class=n>cfs_rq</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>cfs_bandwidth</span> <span class=o>*</span><span class=n>cfs_b</span> <span class=o>=</span> <span class=nf>tg_cfs_bandwidth</span><span class=p>(</span><span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>tg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>raw_spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span> <span class=c1>// &lt;---------- Lock
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ret</span> <span class=o>=</span> <span class=nf>__assign_cfs_rq_runtime</span><span class=p>(</span><span class=n>cfs_b</span><span class=p>,</span> <span class=n>cfs_rq</span><span class=p>,</span> <span class=nf>sched_cfs_bandwidth_slice</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=nf>raw_spin_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span> <span class=c1>// &lt;---------- Unlock
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And from the document</p><blockquote><p>all but 1ms of the slice may be returned to the global pool if all threads on that cpu become unrunnable. This is configured at compile time by the <code>min_cfs_rq_runtime</code> variable. This is a performance tweak that helps prevent added contention on the global lock.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__return_cfs_rq_runtime</span><span class=p>(</span><span class=k>struct</span> <span class=n>cfs_rq</span> <span class=o>*</span><span class=n>cfs_rq</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>cfs_bandwidth</span> <span class=o>*</span><span class=n>cfs_b</span> <span class=o>=</span> <span class=nf>tg_cfs_bandwidth</span><span class=p>(</span><span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>tg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>s64</span> <span class=n>slack_runtime</span> <span class=o>=</span> <span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>runtime_remaining</span> <span class=o>-</span> <span class=n>min_cfs_rq_runtime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>slack_runtime</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>raw_spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>quota</span> <span class=o>!=</span> <span class=n>RUNTIME_INF</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>runtime</span> <span class=o>+=</span> <span class=n>slack_runtime</span><span class=p>;</span>  <span class=c1>// &lt;---------- Return to the global pool
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/* we are under rq-&gt;lock, defer unthrottling using a timer */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>runtime</span> <span class=o>&gt;</span> <span class=nf>sched_cfs_bandwidth_slice</span><span class=p>()</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=o>!</span><span class=nf>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>throttled_cfs_rq</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>start_cfs_slack_bandwidth</span><span class=p>(</span><span class=n>cfs_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>raw_spin_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cfs_b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* even if it&#39;s not valid for return we don&#39;t want to try again */</span>
</span></span><span class=line><span class=cl>  <span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>runtime_remaining</span> <span class=o>-=</span> <span class=n>slack_runtime</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-side-note-about-spinlock>A Side Note About Spinlock</h3><p>What&rsquo;s intersting while reading the kernel code is that, it uses <strong>spinlock</strong> a lot.</p><p>I believe this is for a performance reason.</p><p>Unlike <strong>mutex locks</strong>, which put the waiting thread to sleep, <strong>spinlocks</strong> make the thread continuously &ldquo;spin&rdquo; until the lock is available. This approach is efficient where critical sections are expected to be short as it avoids the overhead of sleeping and waking threads.</p><br><h2 id=should-we-set-the-cpu-limit>Should We Set the CPU Limit?</h2><br><blockquote class=twitter-tweet><p lang=en dir=ltr>This is why I always advise:<br><br>1) Always set memory limit == request<br>2) Never set CPU limit<br><br>(for locally adjusted values of "always" and "never")</p>&mdash; Tim Hockin (thockin.yaml) (@thockin) <a href="https://twitter.com/thockin/status/1134193838841401345?ref_src=twsrc%5Etfw">May 30, 2019</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p>I think it depends a lot by use case.</p><ul><li>If we want the performance, maybe avoid setting the CPU limit.</li><li>But in some use case where we want <em>consistency</em>, or <em>reproducable</em> performance like load testing, we may want to set the limit.</li></ul><br><h2 id=references>References</h2><ul><li><a href=https://kubernetes.io/docs/concepts/configuration/manage-resources-containers target=_blank rel=noopener>https://kubernetes.io/docs/concepts/configuration/manage-resources-containers</a></li><li><a href=https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/cgroups.html target=_blank rel=noopener>https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/cgroups.html</a></li><li><a href=https://github.com/torvalds/linux target=_blank rel=noopener>https://github.com/torvalds/linux</a></li><li><a href="https://www.reddit.com/r/kubernetes/comments/wgztqh/for_the_love_of_god_stop_using_cpu_limits_on/?rdt=51634" target=_blank rel=noopener>https://www.reddit.com/r/kubernetes/comments/wgztqh/for_the_love_of_god_stop_using_cpu_limits_on/?rdt=51634</a></li><li><a href=https://www.reddit.com/r/kubernetes/comments/12he7aa/cpu_limits/ target=_blank rel=noopener>https://www.reddit.com/r/kubernetes/comments/12he7aa/cpu_limits/</a></li></ul></div><div class=article-tags><a class="badge badge-light" href=/tag/kubernetes/>Kubernetes</a>
<a class="badge badge-light" href=/tag/c/c-/>C/C++</a></div><div class=share-box><ul class=share><li><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fwitsblog.github.io%2Fpost%2F021_k8s_cpu_limit%2F&amp;text=Ever+Wonder+How+Kubernetes+CPU+Limit+Can+Be+a+Fraction%3F" target=_blank rel=noopener class=share-btn-twitter aria-label=twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fwitsblog.github.io%2Fpost%2F021_k8s_cpu_limit%2F&amp;t=Ever+Wonder+How+Kubernetes+CPU+Limit+Can+Be+a+Fraction%3F" target=_blank rel=noopener class=share-btn-facebook aria-label=facebook><i class="fab fa-facebook"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=https%3A%2F%2Fwitsblog.github.io%2Fpost%2F021_k8s_cpu_limit%2F&amp;title=Ever+Wonder+How+Kubernetes+CPU+Limit+Can+Be+a+Fraction%3F" target=_blank rel=noopener class=share-btn-linkedin aria-label=linkedin-in><i class="fab fa-linkedin-in"></i></a></li></ul></div></div></div></div></article></div><div class=page-footer><div class=container><footer class=site-footer></footer></div></div><script src=/js/vendor-bundle.min.938a3a7554cd9f6602290411f64d2617.js></script><script id=search-hit-fuse-template type=text/x-template>
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script><script src=https://cdn.jsdelivr.net/gh/krisk/Fuse@v3.2.1/dist/fuse.min.js integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/gh/julmot/mark.js@8.11.1/dist/jquery.mark.min.js integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin=anonymous></script><script id=page-data type=application/json>{"use_headroom":true}</script><script src=/js/wowchemy-headroom.db4755770454eb63685f8de785c0a172.js type=module></script><script src=/en/js/wowchemy.min.2945731fa88332cb0ec33cf47d29879f.js></script></body></html>